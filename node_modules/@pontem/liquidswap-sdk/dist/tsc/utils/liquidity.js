"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPoolStr = exports.getOptimalLiquidityAmount = exports.calcOutputBurnLiquidity = exports.calcReceivedLP = void 0;
const decimal_js_1 = require("decimal.js");
const numbers_1 = require("./numbers");
const contracts_1 = require("./contracts");
/**
 * Calculate return of Liquidity Coins
 * @param x {number} - x coin value with slippage
 * @param y {number} - y coin value with slippage
 * @param xReserve {number} - x coin reserves
 * @param yReserve {number} - y coin reserves
 * @param lpSupply {number} - liquidity pool supply value
 */
const MINIMAL_LIQUIDITY = 10000;
function calcReceivedLP({ x, y, xReserve, yReserve, lpSupply, }) {
    const dxReserve = (0, numbers_1.d)(xReserve);
    const dyReserve = (0, numbers_1.d)(yReserve);
    const dx = (0, numbers_1.d)(x);
    const dy = (0, numbers_1.d)(y);
    const dSupply = (0, numbers_1.d)(lpSupply);
    if (dxReserve.eq(0) || dyReserve.eq(0)) {
        return decimal_js_1.Decimal.sqrt(dx.mul(dy)).minus(MINIMAL_LIQUIDITY).toFixed(0);
    }
    const xLp = dx.mul(dSupply).div(dxReserve);
    const yLp = dy.mul(dSupply).div(dyReserve);
    return decimal_js_1.Decimal.min(xLp, yLp).toFixed(0);
}
exports.calcReceivedLP = calcReceivedLP;
/**
 * Calculate output amount after burned
 * @param {number} xReserve - first coin reserves
 * @param {number} yReserve - second coin reserves
 * @param {number} lpSupply - liquidity pool supply value
 * @param {number} toBurn - burn amount
 */
function calcOutputBurnLiquidity({ xReserve, yReserve, lpSupply, toBurn, }) {
    const xReturn = toBurn.mul(xReserve).div(lpSupply);
    const yReturn = toBurn.mul(yReserve).div(lpSupply);
    if (xReturn.eq(0) || yReturn.eq(0)) {
        return undefined;
    }
    return {
        x: xReturn,
        y: yReturn,
    };
}
exports.calcOutputBurnLiquidity = calcOutputBurnLiquidity;
function getOptimalLiquidityAmount(xDesired, xReserve, yReserve) {
    return xDesired.mul(yReserve).div(xReserve);
}
exports.getOptimalLiquidityAmount = getOptimalLiquidityAmount;
function getPoolStr(coinX, coinY, curve, modulesLiquidityPool) {
    const [sortedX, sortedY] = (0, contracts_1.is_sorted)(coinX, coinY)
        ? [coinX, coinY]
        : [coinY, coinX];
    return (0, contracts_1.composeType)(modulesLiquidityPool, [sortedX, sortedY, curve]);
}
exports.getPoolStr = getPoolStr;
//# sourceMappingURL=liquidity.js.map