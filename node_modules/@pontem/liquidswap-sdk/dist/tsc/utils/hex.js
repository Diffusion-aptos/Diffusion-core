"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkAptosType = exports.toBuffer = exports.checkAddress = exports.shortAddress = exports.shortString = exports.addHexPrefix = void 0;
const HEX_REGEXP = /^[-+]?[0-9A-Fa-f]+\.?[0-9A-Fa-f]*?$/;
function addHexPrefix(hex) {
    return !hex.startsWith('0x') ? '0x' + hex : hex;
}
exports.addHexPrefix = addHexPrefix;
function shortString(str, start = 4, end = 4) {
    const slen = Math.max(start, 1);
    const elen = Math.max(end, 1);
    return str.slice(0, slen + 2) + ' ... ' + str.slice(-elen);
}
exports.shortString = shortString;
function shortAddress(address, start = 4, end = 4) {
    return shortString(addHexPrefix(address), start, end);
}
exports.shortAddress = shortAddress;
function checkAddress(address, options = { leadingZero: true }) {
    if (typeof address !== 'string') {
        return false;
    }
    let str = address;
    if (options.leadingZero) {
        if (!address.startsWith('0x')) {
            return false;
        }
        else {
            str = str.substring(2);
        }
    }
    return HEX_REGEXP.test(str);
}
exports.checkAddress = checkAddress;
/**
 * Attempts to turn a value into a `Buffer`.
 * As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.
 * @param v the value
 */
function toBuffer(v) {
    if (!Buffer.isBuffer(v)) {
        if (Array.isArray(v)) {
            v = Buffer.from(v);
        }
        else if (typeof v === 'string') {
            if (exports.isHexString(v)) {
                v = Buffer.from(exports.padToEven(exports.stripHexPrefix(v)), 'hex');
            }
            else {
                v = Buffer.from(v);
            }
        }
        else if (typeof v === 'number') {
            v = exports.intToBuffer(v);
        }
        else if (v === null || v === undefined) {
            v = Buffer.allocUnsafe(0);
        }
        else if (v.toArray) {
            // converts a BN to a Buffer
            v = Buffer.from(v.toArray());
        }
        else {
            throw new Error('invalid type');
        }
    }
    return v;
}
exports.toBuffer = toBuffer;
function checkAptosType(type, options = { leadingZero: true }) {
    var _a, _b, _c, _d, _e;
    if (typeof type !== 'string') {
        return false;
    }
    let _type = type.replace(/\s/g, '');
    const openBracketsCount = (_b = (_a = _type.match(/</g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
    const closeBracketsCount = (_d = (_c = _type.match(/>/g)) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0;
    if (openBracketsCount !== closeBracketsCount) {
        return false;
    }
    const genericsString = _type.match(/(<.+>)$/);
    const generics = (_e = genericsString === null || genericsString === void 0 ? void 0 : genericsString[1]) === null || _e === void 0 ? void 0 : _e.match(/(\w+::\w+::\w+)(?:<.*?>(?!>))?/g);
    if (generics) {
        _type = _type.slice(0, _type.indexOf('<'));
        const validGenerics = generics.every((g) => {
            var _a, _b, _c, _d;
            const gOpenCount = (_b = (_a = g.match(/</g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
            const gCloseCount = (_d = (_c = g.match(/>/g)) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0;
            let t = g;
            if (gOpenCount !== gCloseCount) {
                t = t.slice(0, -(gCloseCount - gOpenCount));
            }
            return checkAptosType(t, options);
        });
        if (!validGenerics) {
            return false;
        }
    }
    const parts = _type.split('::');
    if (parts.length !== 3) {
        return false;
    }
    return (checkAddress(parts[0], options) &&
        parts[1].length >= 1 &&
        parts[2].length >= 1);
}
exports.checkAptosType = checkAptosType;
//# sourceMappingURL=hex.js.map