"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCurve = exports.getScriptsFor = exports.checkAptosType = exports.extractAddressFromType = exports.withSlippage = exports.composeType = exports.is_sorted = void 0;
const tslib_1 = require("tslib");
const buffer_1 = require("buffer");
const decimal_js_1 = tslib_1.__importDefault(require("decimal.js"));
const constants_1 = require("../constants");
const hex_1 = require("./hex");
const EQUAL = 0;
const LESS_THAN = 1;
const GREATER_THAN = 2;
function cmp(a, b) {
    if (a === b) {
        return EQUAL;
    }
    else if (a < b) {
        return LESS_THAN;
    }
    else {
        return GREATER_THAN;
    }
}
function compare(symbolX, symbolY) {
    const lenCmp = cmp(symbolX.length, symbolY.length);
    if (lenCmp != EQUAL) {
        return lenCmp;
    }
    let i = 0;
    while (i < symbolX.length && i < symbolY.length) {
        const elem_cmp = cmp(symbolX.charCodeAt(i), symbolY.charCodeAt(i));
        if (elem_cmp != EQUAL)
            return elem_cmp;
        i++;
    }
    return EQUAL;
}
function cmp_addresses(a, b) {
    if (a.startsWith('0x')) {
        a = a.substring(2);
    }
    if (a.length != 64) {
        while (a.length < 64) {
            a = '0' + a;
        }
    }
    if (b.startsWith('0x')) {
        b = b.substring(2);
    }
    if (b.length != 64) {
        while (b.length < 64) {
            b = '0' + b;
        }
    }
    const a_buf = buffer_1.Buffer.from(a, 'hex');
    const b_buf = buffer_1.Buffer.from(b, 'hex');
    for (let i = 0; i < 32; i++) {
        if (a_buf[i] < b_buf[i]) {
            return LESS_THAN;
        }
        else if (a_buf[i] > b_buf[i]) {
            return GREATER_THAN;
        }
    }
    return EQUAL;
}
function compare_types(coin_x, coin_y) {
    const coin_x_parts = coin_x.split('::').reverse();
    const coin_y_parts = coin_y.split('::').reverse();
    const coin_x_address = coin_x_parts.pop();
    const coin_y_address = coin_y_parts.pop();
    for (let i = 0; i < 2; i++) {
        const c = compare(coin_x_parts[i], coin_y_parts[i]);
        if (c != EQUAL) {
            return c;
        }
    }
    return cmp_addresses(coin_x_address, coin_y_address);
}
/**
 * Compare sorting between two coin types
 *
 * @param coin_x string with full address of coin
 * @param coin_y string with full address of coin
 * @returns boolean
 */
function is_sorted(coin_x, coin_y) {
    return compare_types(coin_x, coin_y) == LESS_THAN;
}
exports.is_sorted = is_sorted;
function composeType(address, ...args) {
    const generics = Array.isArray(args[args.length - 1])
        ? args.pop()
        : [];
    const chains = [address, ...args].filter(Boolean);
    let result = chains.join('::');
    if (generics && generics.length) {
        result += `<${generics.join(',')}>`;
    }
    return result;
}
exports.composeType = composeType;
/**
 * Calculate value with slippage.
 * @param {Decimal} slippage - slippage refers to the difference between the expected price of a trade
 * and the price at which the trade is executed.
 * @param {Decimal} value - value to calculate slippage
 */
function withSlippage(slippage, value, isPlussed) {
    const multiply = new decimal_js_1.default(10000);
    const slippagePercent = slippage.mul(multiply);
    return isPlussed
        ? value.plus(value.mul(slippagePercent).div(multiply)).toNumber()
        : value.minus(value.mul(slippagePercent).div(multiply)).toNumber();
}
exports.withSlippage = withSlippage;
function extractAddressFromType(type) {
    return type.split('::')[0];
}
exports.extractAddressFromType = extractAddressFromType;
function checkAptosType(type, options = { leadingZero: true }) {
    var _a, _b, _c, _d, _e;
    if (typeof type !== 'string') {
        return false;
    }
    let _type = type.replace(/\s/g, '');
    const openBracketsCount = (_b = (_a = _type.match(/</g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
    const closeBracketsCount = (_d = (_c = _type.match(/>/g)) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0;
    if (openBracketsCount !== closeBracketsCount) {
        return false;
    }
    const genericsString = _type.match(/(<.+>)$/);
    const generics = (_e = genericsString === null || genericsString === void 0 ? void 0 : genericsString[1]) === null || _e === void 0 ? void 0 : _e.match(/(\w+::\w+::\w+)(?:<.*?>(?!>))?/g);
    if (generics) {
        _type = _type.slice(0, _type.indexOf('<'));
        const validGenerics = generics.every((g) => {
            var _a, _b, _c, _d;
            const gOpenCount = (_b = (_a = g.match(/</g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
            const gCloseCount = (_d = (_c = g.match(/>/g)) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0;
            let t = g;
            if (gOpenCount !== gCloseCount) {
                t = t.slice(0, -(gCloseCount - gOpenCount));
            }
            return checkAptosType(t, options);
        });
        if (!validGenerics) {
            return false;
        }
    }
    const parts = _type.split('::');
    if (parts.length !== 3) {
        return false;
    }
    return ((0, hex_1.checkAddress)(parts[0], options) &&
        parts[1].length >= 1 &&
        parts[2].length >= 1);
}
exports.checkAptosType = checkAptosType;
/**
 * Get Script Modules Name for a Contract Version
 *
 * @throws Unknown contract version requested
 *
 * @param contract version number
 * @returns script with scripts module name value
 */
function getScriptsFor(version) {
    if (version === constants_1.VERSION_0_5)
        return constants_1.SCRIPTS_V1;
    switch (version) {
        case constants_1.VERSION_0:
            return constants_1.SCRIPTS_V2;
        case constants_1.VERSION_0_5:
            return constants_1.SCRIPTS_V1;
    }
    throw new Error('Unknown contract version requested');
}
exports.getScriptsFor = getScriptsFor;
/**
 * Compute full curve type for given contract version
 *
 * @param type short name of curve
 * @param contract version
 * @param curves curves from sdk
 * @returns curve full type
 *
 */
function getCurve(type, curves, contract) {
    if (contract === constants_1.VERSION_0_5) {
        if (type === 'stable') {
            return curves.stableV05;
        }
        return curves.uncorrelatedV05;
    }
    if (type === 'stable') {
        return curves.stable;
    }
    return curves.uncorrelated;
}
exports.getCurve = getCurve;
//# sourceMappingURL=contracts.js.map