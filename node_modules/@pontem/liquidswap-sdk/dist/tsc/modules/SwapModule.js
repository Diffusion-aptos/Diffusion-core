"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SwapModule = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("../utils");
const constants_1 = require("../constants");
const contracts_1 = require("../utils/contracts");
class SwapModule {
    constructor(sdk) {
        this._sdk = sdk;
    }
    get sdk() {
        return this._sdk;
    }
    getAmountIn(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.calculateRates(Object.assign(Object.assign({}, params), { interactiveToken: 'from' }));
        });
    }
    getAmountOut(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.calculateRates(Object.assign(Object.assign({}, params), { interactiveToken: 'to' }));
        });
    }
    calculateRates(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { modules } = this.sdk.networkOptions;
            let fromCoinInfo;
            try {
                fromCoinInfo =
                    yield this.sdk.Resources.fetchAccountResource((0, utils_1.extractAddressFromType)(params.fromToken), (0, utils_1.composeType)(modules.CoinInfo, [params.fromToken]));
            }
            catch (e) {
                console.log(e);
            }
            let toCoinInfo;
            try {
                toCoinInfo =
                    yield this.sdk.Resources.fetchAccountResource((0, utils_1.extractAddressFromType)(params.toToken), (0, utils_1.composeType)(modules.CoinInfo, [params.toToken]));
            }
            catch (e) {
                console.log(e);
            }
            if (!fromCoinInfo) {
                throw new Error('From Coin not exists');
            }
            if (!toCoinInfo) {
                throw new Error('To Coin not exists');
            }
            const { liquidityPoolType, liquidityPoolResource } = yield this.getLiquidityPoolResource(params);
            if (!liquidityPoolResource) {
                throw new Error(`LiquidityPool (${liquidityPoolType}) not found`);
            }
            const isSorted = (0, utils_1.is_sorted)(params.fromToken, params.toToken);
            const [sortedFromCoinInfo, sortedToCoinInfo] = isSorted
                ? [fromCoinInfo, toCoinInfo]
                : [toCoinInfo, fromCoinInfo];
            const fromReserve = isSorted
                ? (0, utils_1.d)(liquidityPoolResource.data.coin_x_reserve.value)
                : (0, utils_1.d)(liquidityPoolResource.data.coin_y_reserve.value);
            const toReserve = isSorted
                ? (0, utils_1.d)(liquidityPoolResource.data.coin_y_reserve.value)
                : (0, utils_1.d)(liquidityPoolResource.data.coin_x_reserve.value);
            let fee = (0, utils_1.d)(liquidityPoolResource.data.fee);
            if (params.additionalFee) {
                fee = fee.plus(params.additionalFee);
            }
            const coinFromDecimals = +sortedFromCoinInfo.data.decimals;
            const coinToDecimals = +sortedToCoinInfo.data.decimals;
            const amount = (0, utils_1.d)(params.amount);
            if (amount.comparedTo(0) === 0) {
                throw new Error(`Amount equals zero or undefined`);
            }
            if (params.interactiveToken === 'to' && toReserve.lessThan(amount)) {
                throw new Error(`Insufficient funds in Liquidity Pool`);
            }
            let rate;
            if (params.curveType === 'uncorrelated') {
                rate =
                    params.interactiveToken === 'from'
                        ? (0, utils_1.getCoinOutWithFees)(amount, fromReserve, toReserve, fee)
                        : (0, utils_1.getCoinInWithFees)(amount, toReserve, fromReserve, fee);
            }
            else {
                rate =
                    params.interactiveToken === 'from'
                        ? (0, utils_1.getCoinsOutWithFeesStable)(amount, fromReserve, toReserve, (0, utils_1.d)(Math.pow(10, coinFromDecimals)), (0, utils_1.d)(Math.pow(10, coinToDecimals)), fee)
                        : (0, utils_1.getCoinsInWithFeesStable)(amount, toReserve, fromReserve, (0, utils_1.d)(Math.pow(10, coinToDecimals)), (0, utils_1.d)(Math.pow(10, coinFromDecimals)), fee);
            }
            return rate.toFixed(0);
        });
    }
    createSwapTransactionPayload(params) {
        const curves = this.sdk.curves;
        const slippage = (0, utils_1.d)(params.slippage);
        if (slippage.gte(1) || slippage.lte(0)) {
            throw new Error(`Invalid slippage (${params.slippage}) value, it should be from 0 to 1`);
        }
        const { moduleAccountV05, moduleAccount } = this.sdk.networkOptions;
        const { version = constants_1.VERSION_0 } = params;
        const isUnchecked = version === constants_1.VERSION_0 &&
            params.curveType === 'stable' &&
            params.stableSwapType === 'normal';
        const scriptsVersion = (0, contracts_1.getScriptsFor)(version);
        const moduleAcc = version === constants_1.VERSION_0_5 ? moduleAccountV05 : moduleAccount;
        const functionName = (0, utils_1.composeType)(moduleAcc, scriptsVersion, isUnchecked
            ? 'swap_unchecked'
            : params.interactiveToken === 'from'
                ? 'swap'
                : 'swap_into');
        const curve = (0, contracts_1.getCurve)(params.curveType, curves, version);
        const typeArguments = [params.fromToken, params.toToken, curve];
        const fromAmount = params.interactiveToken === 'from'
            ? params.fromAmount
            : params.curveType === 'stable'
                ? params.fromAmount
                : (0, utils_1.withSlippage)(slippage, (0, utils_1.d)(params.fromAmount), true).toFixed(0);
        const toAmount = params.interactiveToken === 'to'
            ? params.toAmount
            : params.curveType === 'stable'
                ? (0, utils_1.d)(params.toAmount).minus(1).toNumber().toString()
                : (0, utils_1.withSlippage)(slippage, (0, utils_1.d)(params.toAmount), false).toFixed(0);
        const args = [fromAmount.toString(), toAmount.toString()];
        return {
            type: 'entry_function_payload',
            function: functionName,
            type_arguments: typeArguments,
            arguments: args,
        };
    }
    getLiquidityPoolResource(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { resourceAccount, moduleAccount, resourceAccountV05, moduleAccountV05 } = this.sdk.networkOptions;
            const curves = this.sdk.curves;
            const version = params.version;
            const curve = (0, contracts_1.getCurve)(params.curveType, curves, version);
            const moduleAcc = version === constants_1.VERSION_0_5 ? moduleAccountV05 : moduleAccount;
            const resourceAcc = version === constants_1.VERSION_0_5 ? resourceAccountV05 : resourceAccount;
            const modulesLiquidityPool = (0, utils_1.composeType)(moduleAcc, 'liquidity_pool', 'LiquidityPool');
            function getPoolStr(coinX, coinY, curve) {
                const [sortedX, sortedY] = (0, utils_1.is_sorted)(coinX, coinY)
                    ? [coinX, coinY]
                    : [coinY, coinX];
                return (0, utils_1.composeType)(modulesLiquidityPool, [sortedX, sortedY, curve]);
            }
            const liquidityPoolType = getPoolStr(params.fromToken, params.toToken, curve);
            let liquidityPoolResource;
            try {
                liquidityPoolResource =
                    yield this.sdk.Resources.fetchAccountResource(resourceAcc, liquidityPoolType);
            }
            catch (e) {
                console.log(e);
            }
            return { liquidityPoolType, liquidityPoolResource };
        });
    }
}
exports.SwapModule = SwapModule;
//# sourceMappingURL=SwapModule.js.map