"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LiquidityModule = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("../utils");
const constants_1 = require("../constants");
const contracts_1 = require("../utils/contracts");
class LiquidityModule {
    constructor(sdk) {
        this._sdk = sdk;
    }
    get sdk() {
        return this._sdk;
    }
    checkPoolExistence(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { moduleAccount, resourceAccount, moduleAccountV05, resourceAccountV05 } = this.sdk.networkOptions;
            const curves = this.sdk.curves;
            const { version = constants_1.VERSION_0 } = params;
            const moduleAcc = version === constants_1.VERSION_0_5 ? moduleAccountV05 : moduleAccount;
            const resourceAcc = version === constants_1.VERSION_0_5 ? resourceAccountV05 : resourceAccount;
            const modulesLiquidityPool = (0, utils_1.composeType)(moduleAcc, 'liquidity_pool', 'LiquidityPool');
            const curve = (0, contracts_1.getCurve)(params.curveType, curves, version);
            const liquidityPoolType = (0, utils_1.getPoolStr)(params.fromToken, params.toToken, curve, modulesLiquidityPool);
            try {
                const liquidityPoolResource = yield this.sdk.Resources.fetchAccountResource(resourceAcc, liquidityPoolType);
                return Boolean(liquidityPoolResource === null || liquidityPoolResource === void 0 ? void 0 : liquidityPoolResource.type);
            }
            catch (_e) {
                return false;
            }
        });
    }
    getLiquidityPoolResource(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { moduleAccount, resourceAccount, moduleAccountV05, resourceAccountV05 } = this.sdk.networkOptions;
            const curves = this.sdk.curves;
            const { version = constants_1.VERSION_0 } = params;
            const moduleAcc = version === constants_1.VERSION_0_5 ? moduleAccountV05 : moduleAccount;
            const resourceAcc = version === constants_1.VERSION_0_5 ? resourceAccountV05 : resourceAccount;
            const curve = (0, contracts_1.getCurve)(params.curveType, curves, version);
            const modulesLiquidityPool = (0, utils_1.composeType)(moduleAcc, 'liquidity_pool', 'LiquidityPool');
            const liquidityPoolType = (0, utils_1.getPoolStr)(params.fromToken, params.toToken, curve, modulesLiquidityPool);
            let liquidityPoolResource;
            try {
                liquidityPoolResource =
                    yield this.sdk.Resources.fetchAccountResource(resourceAcc, liquidityPoolType);
            }
            catch (e) {
                console.log(e);
            }
            return { liquidityPoolResource };
        });
    }
    getLiquiditySupplyResource(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const curves = this.sdk.curves;
            const { modules, resourceAccount, resourceAccountV05 } = this.sdk.networkOptions;
            const { version = constants_1.VERSION_0 } = params;
            const curve = (0, contracts_1.getCurve)(params.curveType, curves, version);
            const resourceAcc = version === constants_1.VERSION_0_5 ? resourceAccountV05 : resourceAccount;
            function getPoolLpStr(coinX, coinY, curve) {
                const [sortedX, sortedY] = (0, utils_1.is_sorted)(coinX, coinY)
                    ? [coinX, coinY]
                    : [coinY, coinX];
                return (0, utils_1.composeType)(resourceAcc, 'lp_coin', 'LP', [sortedX, sortedY, curve]);
            }
            const lpString = getPoolLpStr(params.fromToken, params.toToken, curve);
            let liquidityPoolResource;
            try {
                liquidityPoolResource =
                    yield this.sdk.Resources.fetchAccountResource(resourceAcc, (0, utils_1.composeType)(modules.CoinInfo, [lpString]));
            }
            catch (e) {
                console.log(e);
            }
            return { liquidityPoolResource };
        });
    }
    calculateSupply(params) {
        const value = (0, utils_1.calcReceivedLP)({
            x: (0, utils_1.withSlippage)((0, utils_1.d)(params.slippage), params.isSorted ? (0, utils_1.d)(params.fromAmount) : (0, utils_1.d)(params.toAmount), false),
            y: (0, utils_1.withSlippage)((0, utils_1.d)(params.slippage), params.isSorted ? (0, utils_1.d)(params.toAmount) : (0, utils_1.d)(params.fromAmount), false),
            xReserve: params.isSorted ? (0, utils_1.d)(params.fromReserve) : (0, utils_1.d)(params.toReserve),
            yReserve: params.isSorted ? (0, utils_1.d)(params.toReserve) : (0, utils_1.d)(params.fromReserve),
            lpSupply: params.lpSupply,
        });
        return value;
    }
    getAmountIn(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { rate } = yield this.calculateRateAndMinReceivedLP(Object.assign(Object.assign({}, params), { interactiveToken: 'from' }));
            return rate;
        });
    }
    getAmountOut(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { rate } = yield this.calculateRateAndMinReceivedLP(Object.assign(Object.assign({}, params), { interactiveToken: 'to' }));
            return rate;
        });
    }
    calculateRateAndMinReceivedLP(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { modules } = this.sdk.networkOptions;
            let fromCoinInfo;
            try {
                fromCoinInfo =
                    yield this.sdk.Resources.fetchAccountResource((0, utils_1.extractAddressFromType)(params.fromToken), (0, utils_1.composeType)(modules.CoinInfo, [params.fromToken]));
            }
            catch (e) {
                console.log(e);
            }
            let toCoinInfo;
            try {
                toCoinInfo =
                    yield this.sdk.Resources.fetchAccountResource((0, utils_1.extractAddressFromType)(params.toToken), (0, utils_1.composeType)(modules.CoinInfo, [params.toToken]));
            }
            catch (e) {
                console.log(e);
            }
            if (!fromCoinInfo) {
                throw new Error('From Coin not exists');
            }
            if (!toCoinInfo) {
                throw new Error('To Coin not exists');
            }
            const isSorted = (0, utils_1.is_sorted)(params.fromToken, params.toToken);
            const { liquidityPoolResource } = yield this.getLiquidityPoolResource(params);
            if (!liquidityPoolResource) {
                throw new Error(`LiquidityPool not existed`);
            }
            const fromReserve = isSorted
                ? (0, utils_1.d)(liquidityPoolResource.data.coin_x_reserve.value)
                : (0, utils_1.d)(liquidityPoolResource.data.coin_y_reserve.value);
            const toReserve = isSorted
                ? (0, utils_1.d)(liquidityPoolResource.data.coin_y_reserve.value)
                : (0, utils_1.d)(liquidityPoolResource.data.coin_x_reserve.value);
            const optimalAmount = params.interactiveToken === 'from'
                ? (0, utils_1.getOptimalLiquidityAmount)((0, utils_1.d)(params.amount), fromReserve, toReserve)
                : (0, utils_1.getOptimalLiquidityAmount)((0, utils_1.d)(params.amount), toReserve, fromReserve);
            const { liquidityPoolResource: lpSupplyResponse } = yield this.getLiquiditySupplyResource(params);
            if (!lpSupplyResponse) {
                throw new Error(`lpSupplyResponse not existed`);
            }
            let lpSupply;
            try {
                // TODO: fix typing
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                lpSupply = lpSupplyResponse.data.supply.vec[0].integer.vec[0].value;
            }
            catch (e) {
                console.log(e);
            }
            const receiveLp = this.calculateSupply({
                slippage: params.slippage,
                fromReserve,
                toReserve,
                fromAmount: params.interactiveToken === 'from' ? params.amount : optimalAmount,
                toAmount: params.interactiveToken === 'to' ? params.amount : optimalAmount,
                lpSupply: lpSupply,
                isSorted,
            });
            return { rate: optimalAmount.toFixed(0), receiveLp };
        });
    }
    createAddLiquidityPayload(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const slippage = (0, utils_1.d)(params.slippage);
            if (slippage.gte(1) || slippage.lte(0)) {
                throw new Error(`Invalid slippage (${params.slippage}) value, it should be from 0 to 1`);
            }
            const isPoolExisted = yield this.checkPoolExistence(params);
            const { version = constants_1.VERSION_0 } = params;
            const { moduleAccountV05, moduleAccount } = this.sdk.networkOptions;
            const moduleAcc = version === constants_1.VERSION_0_5 ? moduleAccountV05 : moduleAccount;
            const curves = this.sdk.curves;
            const scriptsVersion = (0, contracts_1.getScriptsFor)(version);
            const functionName = (0, utils_1.composeType)(moduleAcc, scriptsVersion, isPoolExisted ? 'add_liquidity' : 'register_pool_and_add_liquidity');
            const curve = (0, contracts_1.getCurve)(params.curveType, curves, version);
            const isSorted = (0, utils_1.is_sorted)(params.fromToken, params.toToken);
            const typeArguments = isSorted
                ? [params.fromToken, params.toToken, curve]
                : [params.toToken, params.fromToken, curve];
            const fromAmountWithSlippage = (0, utils_1.withSlippage)((0, utils_1.d)(params.slippage), (0, utils_1.d)(params.fromAmount), false).toFixed(0);
            const toAmountWithSlippage = (0, utils_1.withSlippage)((0, utils_1.d)(params.slippage), (0, utils_1.d)(params.toAmount), false).toFixed(0);
            const args = isSorted
                ? [
                    params.fromAmount.toString(),
                    fromAmountWithSlippage,
                    params.toAmount.toString(),
                    toAmountWithSlippage,
                ]
                : [
                    params.toAmount.toString(),
                    toAmountWithSlippage,
                    params.fromAmount.toString(),
                    fromAmountWithSlippage,
                ];
            return {
                type: 'entry_function_payload',
                function: functionName,
                type_arguments: typeArguments,
                arguments: args,
            };
        });
    }
    createBurnLiquidityPayload(params) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const slippage = (0, utils_1.d)(params.slippage);
            if (slippage.gte(1) || slippage.lte(0)) {
                throw new Error(`Invalid slippage (${params.slippage}) value, it should be from 0 to 1`);
            }
            const { version = constants_1.VERSION_0 } = params;
            const curves = this.sdk.curves;
            const curve = (0, contracts_1.getCurve)(params.curveType, curves, version);
            const { moduleAccountV05, moduleAccount } = this.sdk.networkOptions;
            const moduleAcc = version === constants_1.VERSION_0_5 ? moduleAccountV05 : moduleAccount;
            const output = yield this.calculateOutputBurn(params);
            const xOutput = (_a = output === null || output === void 0 ? void 0 : output.x) !== null && _a !== void 0 ? _a : '0';
            const yOutput = (_b = output === null || output === void 0 ? void 0 : output.y) !== null && _b !== void 0 ? _b : '0';
            const isSorted = (0, utils_1.is_sorted)(params.fromToken, params.toToken);
            const args = isSorted
                ? [params.burnAmount.toString(), xOutput, yOutput]
                : [params.burnAmount.toString(), yOutput, xOutput];
            const scriptsVersion = (0, contracts_1.getScriptsFor)(version);
            const functionName = (0, utils_1.composeType)(moduleAcc, scriptsVersion, 'remove_liquidity');
            const typeArguments = isSorted
                ? [params.fromToken, params.toToken, curve]
                : [params.toToken, params.fromToken, curve];
            return {
                type: 'entry_function_payload',
                function: functionName,
                type_arguments: typeArguments,
                arguments: args,
            };
        });
    }
    calculateOutputBurn(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { liquidityPoolResource } = yield this.getLiquidityPoolResource(params);
            const { liquidityPoolResource: lpSupplyResponse } = yield this.getLiquiditySupplyResource(params);
            if (!lpSupplyResponse) {
                throw new Error(`lpSupplyResponse not existed`);
            }
            let lpSupply;
            try {
                // TODO: fix typing
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                lpSupply = lpSupplyResponse.data.supply.vec[0].integer.vec[0].value;
            }
            catch (e) {
                console.log(e);
            }
            if (!liquidityPoolResource) {
                throw new Error(`LiquidityPool not existed`);
            }
            const isSorted = (0, utils_1.is_sorted)(params.fromToken, params.toToken);
            const fromReserve = isSorted
                ? (0, utils_1.d)(liquidityPoolResource.data.coin_x_reserve.value)
                : (0, utils_1.d)(liquidityPoolResource.data.coin_y_reserve.value);
            const toReserve = isSorted
                ? (0, utils_1.d)(liquidityPoolResource.data.coin_y_reserve.value)
                : (0, utils_1.d)(liquidityPoolResource.data.coin_x_reserve.value);
            const outputVal = (0, utils_1.calcOutputBurnLiquidity)({
                xReserve: fromReserve,
                yReserve: toReserve,
                lpSupply: (0, utils_1.d)(lpSupply),
                toBurn: (0, utils_1.d)(params.burnAmount),
            });
            if (!outputVal) {
                return;
            }
            return {
                x: (0, utils_1.withSlippage)((0, utils_1.d)(params.slippage), outputVal['x'], false).toFixed(0),
                y: (0, utils_1.withSlippage)((0, utils_1.d)(params.slippage), outputVal['y'], false).toFixed(0),
                withoutSlippage: {
                    x: outputVal['x'].toFixed(0),
                    y: outputVal['y'].toFixed(0),
                },
            };
        });
    }
}
exports.LiquidityModule = LiquidityModule;
//# sourceMappingURL=LiquidityModule.js.map